Authentication with JWT and Google Login (OAuth 2.0)
    This process combines the convenience of Google's OAuth 2.0 for user authentication with the efficiency of JWTs for subsequent authorization.

Step 1: Obtain OAuth 2.0 Client Credentials from Google
    Before you begin coding, you need to set up your project in the Google Cloud Console.

    Navigate to Google Cloud Console: Go to https://console.cloud.google.com/apis/dashboard?inv=1&invt=Abz_dQ&project=my-project-mentorpick (or your project's equivalent dashboard).
    Create OAuth Consent Screen: Configure your application's consent screen, providing details like application name, user support email, and authorized domains.
    Create OAuth 2.0 Client IDs:
    For the Client (Frontend): Create a "Web application" client ID. This will give you a Client ID. This ID is publicly exposed and used by your frontend to initiate the Google login flow.
    For the Server (Backend): Create another "Web application" client ID (or "Web server" if applicable, though "Web application" generally works for both). This will provide you with a Client ID and a Client Secret. 
    The Client Secret is confidential and should never be exposed on the frontend.
    
Step 2: User Login with Google Consent (Client-Side)
    This step occurs on your frontend application.
    Initiate Google Login: Your frontend application will use the Google Sign-In library (e.g., Google Identity Services library for web) to initiate the OAuth 2.0 flow.
    User Consent: The user is redirected to Google's authentication page, where they review the permissions your application is requesting and grant consent.
    Receive Google Token: Upon successful consent, Google redirects the user back to your specified redirect URI (configured in the Google Cloud Console). As part of this redirect, your frontend receives a Google ID Token (a JWT issued by Google) and potentially an access token.

Step 3: Pass Google Token to Server (Client-Side)
    Send to Backend: The frontend takes the received Google ID Token and sends it to your backend server. This is typically done via an HTTP POST request to a dedicated authentication endpoint on your server (e.g., /api/auth/google).

Step 4: Verify Google Token on Server (Server-Side)
    This is a crucial security step on your backend.
    Receive Google Token: Your server's authentication endpoint receives the Google ID Token from the client.
    Verify using google-auth-library: Utilize the google-auth-library NPM package to verify the authenticity and integrity of the received Google ID Token.
    You'll initialize the Google OAuth client with your Server's Client ID.
    The library will make a request to Google's authentication servers to verify the token's signature, issuer, audience (which should match your server's Client ID), and expiration.
    If the verification is successful, the library returns the decoded payload of the Google ID Token, which contains user information (e.g., email, name, picture).

Step 5: Generate and Issue Custom JWT (Server-Side)
    Once the Google ID Token is verified, your server takes control of the authentication.
    Retrieve User Information: Extract relevant user information (e.g., email, Google user ID) from the verified Google ID Token payload.
    Server's JWT Secret Key: Ensure your server has a strong, securely stored JWT Secret Key. This key is used to sign your custom JWTs and should never be exposed publicly.
    Generate Custom JWT: Using a library like jsonwebtoken (NPM package), generate a new JWT with the following characteristics:
    Payload: Include essential user information (e.g., user ID from your database, roles, permissions). Avoid including sensitive data directly in the JWT payload as it's only base64 encoded, not encrypted.
    Signature: Sign the JWT using your server's JWT Secret Key.
    Expiration: Set an appropriate expiration time for the JWT (e.g., 15 minutes, 1 hour).
    Set JWT in HTTP-Only Cookie: The generated JWT is then placed into an HTTP-only cookie in the server's response.
    HTTP-only: This prevents client-side JavaScript from accessing the cookie, mitigating XSS attacks.
    Secure: For production, ensure the Secure flag is set to transmit the cookie only over HTTPS.
    SameSite: Consider setting SameSite to Lax or Strict to mitigate CSRF attacks.

Step 6: Subsequent Requests with JWT (Client & Server)
    Now, your custom JWT is the primary means of authentication and authorization.

    Client Sends Cookie: For every subsequent request from the client to your server, the browser will automatically include the HTTP-only cookie containing your custom JWT.
    Server Receives and Verifies JWT:
    Your server-side middleware or route handlers will access the JWT from the incoming request's cookies.
    Using the jsonwebtoken library and your server's JWT Secret Key, verify the JWT's signature and expiration.
    If the JWT is valid, the decoded payload will be available, containing the user information you embedded.
    Authorization: Based on the user information in the verified JWT payload (e.g., user ID, roles), your server can then make authorization decisions, determining whether the user has permission to access the requested resource or perform the action.
    This flow provides a robust and secure way to handle user authentication and authorization using Google Login and JWTs.